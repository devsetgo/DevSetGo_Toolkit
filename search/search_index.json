{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p> <p>CI/CD Pipeline:  </p> <p>SonarCloud:  </p>"},{"location":"#devsetgo-toolkit","title":"DevSetGo Toolkit","text":"<p>A set of common functions wrapped into a package, so I don't have to write the same code over and over. Oh and it makes the code more reusable.... or something like that.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Can be found here.</p>"},{"location":"#testing","title":"Testing","text":"<p>Test on Windows and Linux. Since I work in Windows and Linux, testing is mostly there. Should work on MacOS, but let me know if there is an issue.</p>"},{"location":"#library-functions","title":"Library Functions","text":"<ul> <li>HTTP Codes</li> <li>Base Schema</li> </ul>"},{"location":"baseschema/","title":"Base Schema Module","text":"<p>This module defines the base schema for database models in the application. It uses SQLAlchemy as the ORM and provides a <code>SchemaBase</code> class that all other models should inherit from. The <code>SchemaBase</code> class includes common columns that are needed for most models like <code>_id</code>, <code>date_created</code>, and <code>date_updated</code>.</p>"},{"location":"baseschema/#columns","title":"Columns","text":"<ul> <li><code>_id</code>: A unique identifier for each record. It's a string representation of a UUID.</li> <li><code>date_created</code>: The date and time when a particular row was inserted into the table. It defaults to the current UTC time when the instance is created.</li> <li><code>date_updated</code>: The date and time when a particular row was last updated. It defaults to the current UTC time whenever the instance is updated.</li> </ul>"},{"location":"baseschema/#usage","title":"Usage","text":"<p>To use this module, import it and extend the <code>SchemaBase</code> class to create new database models. Here's an example:</p> <pre><code>from base_schema import SchemaBase\nfrom sqlalchemy import Column, Integer, String\n\nclass User(SchemaBase):\n    __tablename__ = 'users'\n\n    name = Column(String, index=True)\n    age = Column(Integer)\n</code></pre>"},{"location":"baseschema/#full-example","title":"Full Example","text":"<p>This example can be found in the example folder of the repo.</p> <pre><code># -*- coding: utf-8 -*-\nfrom datetime import datetime\nfrom typing import List\n\nfrom dsg_lib.logging_config import config_log\nfrom fastapi import FastAPI, HTTPException, Query, status\nfrom fastapi.responses import RedirectResponse\nfrom pydantic import BaseModel, ConfigDict, EmailStr, Field\n\n# from sqlalchemy.future import select\nfrom sqlalchemy import Column, Select, String\n\nfrom example import health_check\n\n# , tools\n# from .database_ops import DatabaseOperations\n# from .database_connector import AsyncDatabase\n# from .base_schema import SchemaBase\nfrom devsetgo_toolkit import AsyncDatabase, DatabaseOperations, SchemaBase\n\nconfig_log(\n    logging_directory=\"logs\",\n    log_name=\"log.log\",\n    logging_level=\"INFO\",\n    log_rotation=\"100 MB\",\n    log_retention=\"1 days\",\n    log_backtrace=True,\n    log_format=\"{time:YYYY-MM-DD at HH:mm:ss} | {level} | {message}\",\n    log_serializer=False,\n)\n\nsettings_dict = {\n    # \"database_uri\": \"sqlite+aiosqlite:///:memory:?cache=shared\",\n    \"database_uri\": \"postgresql+asyncpg://postgres:postgres@db/postgres\",\n}\n\nasync_db = AsyncDatabase(settings_dict=settings_dict)\ndb_ops = DatabaseOperations(async_db)\n\n\nclass User(SchemaBase, async_db.Base):\n    __tablename__ = \"users\"\n\n    name_first = Column(String, unique=False, index=True)\n    name_last = Column(String, unique=False, index=True)\n    email = Column(String, unique=True, index=True, nullable=True)\n\n\nclass UserBase(BaseModel):\n    name_first: str = Field(\n        ...,\n        # alias=\"firstName\",\n        description=\"the users first or given name\",\n        examples=[\"Bob\"],\n    )\n    name_last: str = Field(\n        ...,\n        # alias=\"lastName\",\n        description=\"the users last or surname name\",\n        examples=[\"Fruit\"],\n    )\n    email: EmailStr\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass UserResponse(UserBase):\n    _id: str\n    date_created: datetime\n    date_updated: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass UserList(BaseModel):\n    users: List[UserBase]\n\n\napp = FastAPI(title=\"FastAPI Base Schema Example\", description=\"Using Base Schema class with a FastAPI app.\")\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    await async_db.create_tables()\n\n@app.get(\"/\")\nasync def root():\n    return RedirectResponse(\"/docs\", status_code=307)\n\n\n@app.get(\"/users/count\")\nasync def count_users():\n    count = await db_ops.count_query(Select(User))\n    return {\"count\": count}\n\n\n@app.get(\"/users\")\nasync def read_users(\n    limit: int = Query(None, alias=\"limit\", ge=1, le=1000),\n    offset: int = Query(None, alias=\"offset\"),\n):\n    if limit is None:\n        limit = 500\n\n    if offset is None:\n        offset = 0\n\n    query_count = Select(User)\n    total_count = await db_ops.count_query(query=query_count)\n    query = Select(User)\n    users = await db_ops.fetch_query(query=query, limit=limit, offset=offset)\n    return {\n        \"query_data\": {\"total_count\": total_count, \"count\": len(users)},\n        \"users\": users,\n    }\n\n\n@app.post(\"/users/\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\nasync def create_user(user: UserBase):\n    db_user = User(\n        name_first=user.name_first, name_last=user.name_last, email=user.email\n    )\n    created_user = await db_ops.execute_one(db_user)\n    return created_user\n\n\n@app.post(\n    \"/users/bulk/\",\n    response_model=List[UserResponse],\n    status_code=status.HTTP_201_CREATED,\n)\nasync def create_users(user_list: UserList):\n    db_users = [\n        User(name_first=user.name_first, name_last=user.name_last, email=user.email)\n        for user in user_list.users\n    ]\n    created_users = await db_ops.execute_many(db_users)\n    return created_users\n\n\nimport random\nimport string\n\n\n@app.get(\n    \"/users/bulk/auto\",\n    response_model=List[UserResponse],\n    status_code=status.HTTP_201_CREATED,\n)\nasync def create_users_auto(qty: int = Query(100, le=1000, ge=1)):\n    created_users: list = []\n    for i in range(qty):\n        # Generate a random first name, last name\n        name_first = \"\".join(random.choices(string.ascii_lowercase, k=5))\n        name_last = \"\".join(random.choices(string.ascii_lowercase, k=5))\n\n        # Generate a random email\n        random_email_part = \"\".join(\n            random.choices(string.ascii_lowercase + string.digits, k=10)\n        )\n        email = f\"user{random_email_part}@yahoo.com\"\n\n        db_user = User(name_first=name_first, name_last=name_last, email=email)\n        created_user = await db_ops.execute_one(db_user)\n        created_users.append(created_user)\n\n    return created_users\n\n\n@app.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def read_user(user_id: str):\n    users = await db_ops.fetch_query(Select(User).where(User._id == user_id))\n    if not users:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return users[0]\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog</p>"},{"location":"changelog/#todo","title":"Todo","text":""},{"location":"changelog/#unreleased","title":"[Unreleased]","text":"<ul> <li>Tools</li> <li>HTTP Codes</li> <li>User library</li> <li>Base Schema</li> <li>Database Operations</li> <li>Database Connector [partial]</li> </ul>"},{"location":"changelog/#010-initial-beta-release","title":"[0.1.0] - Initial Beta Release","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Project layout</li> <li>Basic tests</li> <li>Simple functions<ul> <li>Database Connector</li> </ul> </li> <li>Start of Documentation</li> </ul>"},{"location":"contribute/","title":"Contributing","text":"<p>Please feel to contribute to this project. Adding common functions is the intent and if you have one to add or improve an existing it is greatly appreciated.</p>"},{"location":"contribute/#ways-to-contribute","title":"Ways to Contribute!","text":"<ul> <li>Add or improve a function</li> <li>Add or improve documentation</li> <li>Add or improve Tests</li> <li>Report or fix a bug</li> </ul>"},{"location":"example/","title":"Example","text":"<p>This is a full example using FastAPI for all of the library functions.</p> <pre><code># -*- coding: utf-8 -*-\n\"\"\"\nThis module defines the FastAPI application and its endpoints.\n\nThe application uses SQLAlchemy for database operations and Pydantic for request and response models. It includes endpoints for creating, reading, and counting users. It also includes a health check endpoint and a tools endpoint.\n\nThe User model is defined with first name, last name, and email fields. The UserBase Pydantic model is used for request validation when creating a new user, and the UserResponse Pydantic model is used for the response.\n\nThe application uses the AsyncDatabase and DatabaseOperations classes from the devsetgo_toolkit library for asynchronous database operations.\n\nThe application is configured to log to a file with a custom format and rotation policy.\n\nThe application includes a startup event that creates the database tables if they don't exist.\n\nThe application's root endpoint redirects to the /docs endpoint, which provides an interactive API documentation.\n\nThe application includes a /users/count endpoint that returns the total number of users, a /users endpoint that returns a list of users with pagination, a /users/ endpoint that creates a new user, a /users/bulk/ endpoint that creates multiple users, a /users/bulk/auto endpoint that automatically generates and creates multiple users, and a /users/{user_id} endpoint that returns the details of a specific user.\n\nThe application includes a /api/v1/tools endpoint and a /api/health endpoint, which are defined in separate routers.\n\"\"\"\nimport logging\nimport random\nimport string\n\n# Import necessary libraries and modules\nfrom datetime import datetime\nfrom typing import List\n\nfrom fastapi import FastAPI\nfrom fastapi import HTTPException\nfrom fastapi import Query\nfrom fastapi import status\nfrom fastapi.responses import ORJSONResponse\nfrom fastapi.responses import RedirectResponse\nfrom pydantic import BaseModel\nfrom pydantic import ConfigDict\nfrom pydantic import EmailStr\nfrom pydantic import Field\nfrom sqlalchemy import Column\nfrom sqlalchemy import Select\nfrom sqlalchemy import String\n\nfrom devsetgo_toolkit import AsyncDatabase\nfrom devsetgo_toolkit import DatabaseOperations\nfrom devsetgo_toolkit import SchemaBase\nfrom devsetgo_toolkit.logger import logger\n\nlogging.basicConfig(filename=\"example.log\", encoding=\"utf-8\", level=logging.WARNING)\n\n# Define a dictionary with the settings for the database connection\nsettings_dict = {\n    # \"database_uri\": \"sqlite+aiosqlite:///:memory:?cache=shared\",  # SQLite connection string (commented out)\n    \"database_uri\": \"postgresql+asyncpg://postgres:postgres@db/postgres\",  # PostgreSQL connection string\n}\n\n# Create an instance of AsyncDatabase with the settings from settings_dict\nasync_db = AsyncDatabase(settings_dict=settings_dict)\n\n# Create an instance of DatabaseOperations with the AsyncDatabase instance\ndb_ops = DatabaseOperations(async_db)\n\n\n# User class inherits from SchemaBase and async_db.Base\n# This class represents the User table in the database\nclass User(SchemaBase, async_db.Base):\n    __tablename__ = \"users\"  # Name of the table in the database\n\n    # Define the columns of the table\n    name_first = Column(String, unique=False, index=True)  # First name of the user\n    name_last = Column(String, unique=False, index=True)  # Last name of the user\n    email = Column(\n        String, unique=True, index=True, nullable=True\n    )  # Email of the user, must be unique\n\n\n# UserBase class inherits from BaseModel\n# This class is used for request validation when creating a new user\nclass UserBase(BaseModel):\n    name_first: str = Field(  # First name of the user\n        ...,  # This means that the field is required\n        description=\"the users first or given name\",  # Description of the field\n        examples=[\"Bob\"],  # Example of a valid input\n    )\n    name_last: str = Field(  # Last name of the user\n        ...,  # This means that the field is required\n        description=\"the users last or surname name\",  # Description of the field\n        examples=[\"Fruit\"],  # Example of a valid input\n    )\n    email: EmailStr  # Email of the user, must be a valid email address\n\n    model_config = ConfigDict(\n        from_attributes=True\n    )  # Configuration for the Pydantic model\n\n\n# UserResponse class inherits from UserBase\n# This class is used for the response when retrieving a user\nclass UserResponse(UserBase):\n    _id: str  # ID of the user\n    date_created: datetime  # Date when the user was created\n    date_updated: datetime  # Date when the user was last updated\n\n    model_config = ConfigDict(\n        from_attributes=True\n    )  # Configuration for the Pydantic model\n\n\n# UserList class inherits from BaseModel\n# This class is used for the response when retrieving a list of users\nclass UserList(BaseModel):\n    users: List[UserBase]  # List of users\n\n\n# Create an instance of the FastAPI class\napp = FastAPI(\n    title=\"FastAPI Example\",  # The title of the API\n    description=\"This is an example of a FastAPI application.\",  # A brief description of the API\n    version=\"0.1.0\",  # The version of the API\n    docs_url=\"/docs\",  # The URL where the API documentation will be served\n    redoc_url=\"/redoc\",  # The URL where the ReDoc documentation will be served\n    openapi_url=\"/openapi.json\",  # The URL where the OpenAPI schema will be served\n    debug=True,  # Enable debug mode\n    middleware=[],  # A list of middleware to include in the application\n    routes=[],  # A list of routes to include in the application\n    default_response_class=ORJSONResponse,  # The default response class to use\n)\n\n\n# This function is run when the FastAPI application starts up\n@app.on_event(\"startup\")\nasync def startup_event():\n    # Create the tables in the database\n    await async_db.create_tables()\n\n\n# This function is run when the FastAPI application shuts down\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    # Add any cleanup code here\n    pass\n\n\n# Define a route for the root (\"/\") URL\n@app.get(\"/\")\nasync def root():\n    # When this route is accessed, redirect the client to \"/docs\" with a 307 status code\n    return RedirectResponse(\"/docs\", status_code=307)\n\n\n# Define a route for the \"/users/count\" URL\n@app.get(\"/users/count\")\nasync def count_users():\n    # Execute a count query on the User table\n    count = await db_ops.count_query(Select(User))\n    # Return the count as a JSON object\n    return {\"count\": count}\n\n\n# Define a route for the \"/users\" URL\n@app.get(\"/users\")\nasync def read_users(\n    limit: int = Query(\n        None, alias=\"limit\", ge=1, le=1000\n    ),  # Query parameter for the maximum number of users to return\n    offset: int = Query(\n        None, alias=\"offset\"\n    ),  # Query parameter for the number of users to skip before starting to return users\n):\n    # If no limit is provided, default to 500\n    if limit is None:\n        limit = 500\n\n    # If no offset is provided, default to 0\n    if offset is None:\n        offset = 0\n\n    # Create a SELECT query for the User table\n    query_count = Select(User)\n    # Execute the count query to get the total number of users\n    total_count = await db_ops.count_query(query=query_count)\n    # Create a SELECT query for the User table\n    query = Select(User)\n    # Execute the SELECT query to get the users, with the provided limit and offset\n    users = await db_ops.fetch_query(query=query, limit=limit, offset=offset)\n    # Return the total number of users, the number of users returned, and the users themselves\n    return {\n        \"query_data\": {\"total_count\": total_count, \"count\": len(users)},\n        \"users\": users,\n    }\n\n\n# Define a route for the \"/users/\" URL that responds to POST requests\n@app.post(\"/users/\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\nasync def create_user(user: UserBase):\n    # Create a new User instance from the provided data\n    db_user = User(\n        name_first=user.name_first, name_last=user.name_last, email=user.email\n    )\n    # Insert the new user into the database\n    created_user = await db_ops.execute_one(db_user)\n    # Return the created user\n    return created_user\n\n\n# Define a route for the \"/users/bulk/\" URL that responds to POST requests\n@app.post(\n    \"/users/bulk/\",\n    response_model=List[UserResponse],\n    status_code=status.HTTP_201_CREATED,\n)\nasync def create_users(user_list: UserList):\n    # Create a list of new User instances from the provided data\n    db_users = [\n        User(name_first=user.name_first, name_last=user.name_last, email=user.email)\n        for user in user_list.users\n    ]\n    # Insert the new users into the database\n    created_users = await db_ops.execute_many(db_users)\n    # Log the created users\n    logger.info(f\"created_users: {created_users}\")\n    # Return the created users\n    return created_users\n\n\n# Define a route for the \"/users/bulk/auto\" URL\n@app.get(\n    \"/users/bulk/auto\",\n    response_model=List[UserResponse],\n    status_code=status.HTTP_201_CREATED,\n)\nasync def create_users_auto(qty: int = Query(100, le=1000, ge=1)):\n    # Initialize an empty list to hold the new User instances\n    db_users: list = []\n    # Generate the specified quantity of users\n    for i in range(qty):\n        # Generate a random first name and last name\n        name_first = \"\".join(random.choices(string.ascii_lowercase, k=5))\n        name_last = \"\".join(random.choices(string.ascii_lowercase, k=5))\n\n        # Generate a random email\n        random_email_part = \"\".join(\n            random.choices(string.ascii_lowercase + string.digits, k=10)\n        )\n        email = f\"user{random_email_part}@yahoo.com\"\n\n        # Create a new User instance and add it to the list\n        db_user = User(name_first=name_first, name_last=name_last, email=email)\n        db_users.append(db_user)\n\n    # Insert the new users into the database\n    created_users = await db_ops.execute_many(db_users)\n\n    # Log the number of created users\n    logger.info(f\"created_users: {len(created_users)}\")\n    # Return the created users\n    return created_users\n\n\n# Define a route for the \"/users/{user_id}\" URL\n@app.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def read_user(user_id: str):\n    # Execute a SELECT query to get the user with the specified ID\n    users = await db_ops.fetch_query(Select(User).where(User._id == user_id))\n    # If no users were found, raise a 404 error\n    if not users:\n        logger.info(f\"user not found: {user_id}\")\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # Log the found user\n    logger.info(f\"users: {users}\")\n    # Return the found user\n    return users[0]\n\n\n# Define a route for the \"/health/status\" URL\n@app.get(\"/health/status\")\nasync def health():\n    # Return the health status of the application\n    return {\"status\": \"UP\"}\n</code></pre>"},{"location":"httpcodes/","title":"HTTP Response Codes","text":"<p>This Python file defines a dictionary of HTTP error codes and their respective descriptions. The dictionary provides a mapping between HTTP error codes and their description strings, which can be used to define or handle custom error responses for an API.</p> <p>The file also includes the function <code>generate_code_dict(codes, description_only=False)</code>, which generates a dictionary of specific HTTP error codes from the <code>http_codes</code> dictionary.</p>"},{"location":"httpcodes/#usage","title":"Usage","text":"<p>You can use this file in the following ways:</p>"},{"location":"httpcodes/#using-the-http_codes-dictionary","title":"Using the <code>http_codes</code> Dictionary","text":"<p>Access any HTTP code's information as follows:</p> <pre><code># Accessing the \"OK\" status code\nhttp_codes[200]\n</code></pre> <p>This will output:</p> <pre><code>{\n    \"description\": \"OK\",\n    \"link\": \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200\"\n}\n</code></pre>"},{"location":"httpcodes/#using-the-generate_code_dict-function","title":"Using the <code>generate_code_dict</code> Function","text":"<p>Generate a dictionary of specific HTTP error codes as follows:</p> <pre><code># Define a list of common HTTP status codes\ncommon_codes = [200, 400, 401, 403, 404, 408, 429, 500, 503]\n\n# Generate a dictionary of these status codes with their descriptions\nMY_CODES = generate_code_dict(common_codes + [206, 304, 307, 410, 418, 502], description_only=True)\n</code></pre> <p>This will return a dictionary where each key is an HTTP error code from the input list and each value is the corresponding description.</p>"},{"location":"httpcodes/#generating-common-error-codes-for-different-request-methods","title":"Generating Common Error Codes for Different Request Methods","text":"<p>Use the <code>generate_code_dict</code> function to generate dictionaries of common error codes for different request methods:</p>"},{"location":"httpcodes/#get-requests","title":"GET Requests","text":"<pre><code>from devsetgo_toolkit import GET_CODES\n\n# Print the default GET_CODES\nprint(GET_CODES)\n\n# Now add an additional status code (418) to the list and generate a new dictionary\nMY_CODES = generate_code_dict(GET_CODES + [418], description_only=False)\nprint(MY_CODES)\n</code></pre>"},{"location":"httpcodes/#post-requests","title":"POST Requests","text":"<pre><code>from devsetgo_toolkit import POST_CODES\n\n# Print the default POST_CODES\nprint(POST_CODES)\n\n# Add an additional status code (418) to the list and generate a new dictionary\nMY_CODES = generate_code_dict(POST_CODES + [418], description_only=False)\nprint(MY_CODES)\n</code></pre>"},{"location":"httpcodes/#put-requests","title":"PUT Requests","text":"<pre><code>from devsetgo_toolkit import PUT_CODES\n\n# Print the default PUT_CODES\nprint(PUT_CODES)\n\n# Add an additional status code (418) to the list and generate a new dictionary\nMY_CODES = generate_code_dict(PUT_CODES + [418], description_only=False)\nprint(MY_CODES)\n</code></pre>"},{"location":"httpcodes/#patch-requests","title":"PATCH Requests","text":"<pre><code>from devsetgo_toolkit import PATCH_CODES\n\n# Print the default PATCH_CODES\nprint(PATCH_CODES)\n\n# Add an additional status code (418) to the list and generate a new dictionary\nMY_CODES = generate_code_dict(PATCH_CODES + [418], description_only=False)\nprint(MY_CODES)\n</code></pre>"},{"location":"httpcodes/#delete-requests","title":"DELETE Requests","text":"<pre><code>from devsetgo_toolkit import DELETE_CODES\n\n# Print the default DELETE_CODES\nprint(DELETE_CODES)\n\n# Add an additional status code (418) to the list and generate a new dictionary\nMY_CODES = generate_code_dict(DELETE_CODES + [418], description_only=False)\nprint(MY_CODES)\n</code></pre> <p>These dictionaries can be used to define HTTP error codes commonly encountered with each type of request method in an API.</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>Install the current code from the Github repo</p> <pre><code>pip install git+https://github.com/devsetgo/DevSetGo_Toolkit.git@main\n</code></pre> <p>Install the development version (may not work or be stable)</p> <pre><code>pip install git+https://github.com/devsetgo/DevSetGo_Toolkit.git@development\n</code></pre>"},{"location":"quickstart/#use","title":"Use","text":""},{"location":"quickstart/#http-codes-get-requests","title":"HTTP Codes GET Requests","text":"<p>Use GET Codes and create a custom list</p> <pre><code>from devsetgo_toolkit import GET_CODES, generate_code_dict\n\n# Print the default GET_CODES\nprint(GET_CODES)\n\n# Now add an additional status code (418) to the list and generate a new dictionary\nMY_CODES = generate_code_dict(GET_CODES + [418], description_only=False)\nprint(MY_CODES)\n</code></pre>"},{"location":"quickstart/#base-schema","title":"Base Schema","text":"<pre><code>from base_schema import SchemaBase\nfrom sqlalchemy import Column, Integer, String\n\nclass User(SchemaBase):\n    __tablename__ = 'users'\n\n    name = Column(String, index=True)\n    age = Column(Integer)\n</code></pre> <pre><code>from devsetgo_toolkit import *\n</code></pre>"}]}